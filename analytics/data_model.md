# Data Model: Identity & Session Management

## Overview
This document defines how users are identified, sessions are managed, and cross-channel linking works (with Phase 2 extensibility).

---

## 1. Identity Hierarchy

```
┌─────────────────────────────────────────────────────────┐
│                    IDENTIFIED USER                       │
│           (user_id = KRA PIN / Phone Number)            │
│                                                          │
│  ┌──────────────────┐    ┌──────────────────┐           │
│  │  Anonymous ID 1   │    │  Anonymous ID 2   │          │
│  │  (Chrome Desktop) │    │  (Safari Mobile)  │          │
│  │                   │    │                   │          │
│  │  ┌────────────┐  │    │  ┌────────────┐  │           │
│  │  │ Session A  │  │    │  │ Session C  │  │           │
│  │  │ Session B  │  │    │  │ Session D  │  │           │
│  │  └────────────┘  │    │  └────────────┘  │           │
│  └──────────────────┘    └──────────────────┘           │
└─────────────────────────────────────────────────────────┘
```

### ID Types

| ID Type | Description | Persistence | Generated By |
|---------|-------------|-------------|--------------|
| `anonymous_id` | Device/browser identifier | localStorage (permanent) | Client SDK |
| `session_id` | Single browsing session | sessionStorage (tab life) | Client SDK |
| `user_id` | Authenticated user (PIN/Phone) | Server-side | Application |
| `external_id` | WhatsApp phone ID (Phase 2) | N/A | WhatsApp API |

---

## 2. Anonymous ID Generation

### Client-Side Logic

```typescript
function getOrCreateAnonymousId(): string {
  const STORAGE_KEY = 'analytics_anonymous_id';
  
  let id = localStorage.getItem(STORAGE_KEY);
  
  if (!id) {
    id = crypto.randomUUID();
    localStorage.setItem(STORAGE_KEY, id);
  }
  
  return id;
}
```

### Persistence Rules
- Stored in `localStorage` (persists across sessions)
- One per browser profile
- Never expires unless user clears storage
- If localStorage unavailable, fallback to cookie with 2-year expiry

---

## 3. Session Management

### Session ID Generation

```typescript
const SESSION_TIMEOUT_MS = 30 * 60 * 1000; // 30 minutes
const SESSION_KEY = 'analytics_session';
const LAST_ACTIVITY_KEY = 'analytics_last_activity';

function getOrCreateSessionId(): string {
  const now = Date.now();
  const lastActivity = parseInt(sessionStorage.getItem(LAST_ACTIVITY_KEY) || '0');
  let sessionId = sessionStorage.getItem(SESSION_KEY);
  
  // Check for timeout
  if (!sessionId || (now - lastActivity) > SESSION_TIMEOUT_MS) {
    sessionId = crypto.randomUUID();
    sessionStorage.setItem(SESSION_KEY, sessionId);
  }
  
  // Update last activity
  sessionStorage.setItem(LAST_ACTIVITY_KEY, now.toString());
  
  return sessionId;
}
```

### Session Boundaries

A new session starts when:
1. **Timeout**: 30 minutes of inactivity
2. **New Tab**: Opening site in new tab (sessionStorage is tab-scoped)
3. **Campaign Change**: UTM parameters differ from previous session
4. **Midnight**: Calendar day rollover (optional)

### Session Attributes (First-Touch)
Captured once at session start:
- `entry_page`: First page URL
- `referrer`: HTTP referrer
- `utm_source`, `utm_medium`, `utm_campaign`: Marketing attribution
- `device_type`, `country_code`: Device context

---

## 4. User Identification (The `identify` Call)

### When to Identify
- User logs in / completes OTP verification
- User provides PII (name, email, phone)
- Returning user is recognized

### Identify Event Structure

```typescript
analytics.identify('A012345678X', {
  name: 'John Doe',
  phone: '+254712345678',
  pin: 'A012345678X',
  email: 'john@example.com'
});
```

### Backend Processing
1. Store in `identities` table: `anonymous_id` → `user_id`
2. Backfill: Optionally update historical events with `user_id`
3. Merge: If same `user_id` linked from multiple `anonymous_id`s, mark as same user

### Identity Merge Diagram

```
Before Identify:
  anonymous_id_1 ──── Session A (events 1-5)
  anonymous_id_2 ──── Session B (events 6-10)

After Identify (both login as user_123):
  user_123 ─────┬──── anonymous_id_1 ──── Session A
               └──── anonymous_id_2 ──── Session B
```

---

## 5. Cross-Channel Identity (Phase 2)

### The Handshake Token Flow

```
┌──────────────────┐          ┌──────────────────┐
│    WhatsApp      │          │    Web App       │
│                  │          │                  │
│ 1. User starts   │          │                  │
│    conversation  │          │                  │
│                  │          │                  │
│ 2. Bot generates │          │                  │
│    handshake_token ────────▶│ URL includes     │
│    (UUID)        │          │ ?hs_token=xyz    │
│                  │          │                  │
│                  │          │ 3. SDK captures  │
│                  │   ◀──────── handshake_complete
│                  │          │    event         │
│                  │          │                  │
│ 4. Backend links │          │                  │
│    conversation_id          │                  │
│    to session_id │          │                  │
└──────────────────┘          └──────────────────┘
```

### Reserved Fields (Phase 1 Stubs)

```typescript
interface EventContext {
  // Phase 1 (always present)
  channel_type: 'web';
  anonymous_id: string;
  session_id: string;
  user_id?: string;
  
  // Phase 2 (nullable in Phase 1)
  external_id?: string;        // WhatsApp phone ID
  handshake_token?: string;    // Cross-channel linking
  conversation_id?: string;    // WhatsApp conversation
}
```

### SDK Stub (Phase 1)

```typescript
// Check for handshake token in URL (no-op in Phase 1)
function checkHandshakeToken(): string | null {
  const params = new URLSearchParams(window.location.search);
  return params.get('hs_token');
}

// Include in every event context
function buildContext(): EventContext {
  return {
    channel_type: 'web',
    anonymous_id: getOrCreateAnonymousId(),
    session_id: getOrCreateSessionId(),
    handshake_token: checkHandshakeToken() || undefined,
    // ...other fields
  };
}
```

---

## 6. Data Flow Summary

```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│   Client    │     │  Collector  │     │  Processor  │
│             │     │             │     │             │
│ Generate:   │     │ Receive:    │     │ Enrich:     │
│ - anon_id   │────▶│ - Validate  │────▶│ - GeoIP     │
│ - session_id│     │ - Queue     │     │ - UA Parse  │
│ - events    │     │             │     │ - Link IDs  │
└─────────────┘     └─────────────┘     └─────────────┘
                                               │
                                               ▼
                                        ┌─────────────┐
                                        │  Database   │
                                        │             │
                                        │ - events    │
                                        │ - sessions  │
                                        │ - identities│
                                        └─────────────┘
```

---

## 7. Privacy Considerations

| Data | Handling |
|------|----------|
| `user_id` (PIN) | Store as-is (internal PII, needed for support) |
| Phone number | Hash in properties, store plain only in `identities` |
| IP Address | Store temporarily, remove after geo enrichment |
| Email | Hash or encrypt at rest |
